/*  -*- Mode: C -*-  */

/* regress-test.c --- miscellaneous tests for snprintfv
 * Copyright (C) 2002 Gary V. Vaughan
 * Originally by Paolo Bonzini, 2002
 * This file is part of Snprintfv.
 *
 * Snprintfv is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * Snprintfv is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that also links with and
 * uses the libopts library from AutoGen, you may include it under
 * the same distribution terms used by the libopts library.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

/* Usually, this is taken care of by AC_SNPRINTFV_INSTALLABLE.  */
#define LIBSNPRINTFV_DLL_IMPORT 1

#include <float.h>
#include <stdio.h>
#include <stdarg.h>
#include "config.h"
#include "printf.h"

static int test = 0;
static int wrong = 0;

void regress (const char *result, const char *ok)
{
  ++test;
  if (strcmp (result, ok))
    {
      ++wrong;
      printf ("===========================================\n"
              "Test %d failed!\n"
              "===========================================\n"
              "Result\n"
              "------\n"
              "%s\n"
              "\n"
              "Correct\n-------\n"
              "%s\n\n", test, result, ok);
    }
}

void
test1 ()
{
  static const char zDne[] = "%6$s"
    "%1$sDO NOT EDIT THIS FILE   (%2$s)\n"
    "%1$s\n"
    "%1$sIt has been AutoGen-ed  %3$s\n"
    "%1$sFrom the definitions    %4$s\n"
    "%1$sand the template file   %5$s";

  static const char zDneOk[] = "six "
    "one DO NOT EDIT THIS FILE   (two )\n"
    "one \n"
    "one It has been AutoGen-ed  three \n"
    "one From the definitions    four \n"
    "one and the template file   five ";

  char *x;
  asprintf(&x, zDne, "one ", "two ", "three ", "four ", "five ", "six " );
  regress (x, zDneOk);
}

void
test2 ()
{
#define bufSize 0x4000
  char zBuf[ bufSize ];
  char *args[3];

  static const char zFmt[] =
    "%s copyright (c) %s %s, all rights reserved\n";

  static const char zFmtOk[] =
    "autogen copyright (c) 1992-2002 Bruce Korb, all rights reserved\n";

  args[0] = "autogen";
  args[1] = "1992-2002";
  args[2] = "Bruce Korb";
 
  snprintfv( zBuf, bufSize, zFmt, (const void *) args );
  regress (zBuf, zFmtOk);
}

#define STRING(x) STRING_(x)
#define STRING_(x) #x

/* Prevent some optimization attempts from the compiler */
void 
x ()
{
}

void
test3_5 ()
{
  float f,g,h;
  float one = 1.0;
  float two = 2.0;
  float four = 4.0;
  char zBuf[ bufSize ];

  /* Test the machine epsilon.

     For the machine epsilon, f+1-1 = f
     But for any smaller number (such as f/2) this is not true.  */

  sprintf (zBuf, "%.*eF", FLT_DIG + 2, FLT_EPSILON);
  sscanf (zBuf, "%e", &f);
  g = f + one;
  h = f / two + one;
  x ();
  if (g - one != f || h - one != 0.0)
    regress (zBuf, STRING(FLT_EPSILON));
  else
    ++test;

  /* Test the minimum normalized value.

     For a normalized value the full number of mantissa bits is
     available, so multiplying by 1+FLT_EPSILON sets the least
     significant bit of the mantissa.
     But for a denormalized value (such as f/2) we lose bits in
     the mantissa and multiplying by 1+FLT_EPSILON gives the
     number itself.  */

  sprintf (zBuf, "%.*eF", FLT_DIG + 2, FLT_MIN);
  sscanf (zBuf, "%e", &f);
  g = f * (1 + FLT_EPSILON);
  h = f / two * (1 + FLT_EPSILON);
  x ();
  if (f == 0.0 || f == g || f / two != h)
    regress (zBuf, STRING(FLT_MIN));
  else
    ++test;

  /* Test the maximum value.

     Test that it is not infinite (f != g) and that f * 2.0
     is infinite (g == h).  */

  sprintf (zBuf, "%.*eF", FLT_DIG + 2, FLT_MAX);
  sscanf (zBuf, "%e", &f);
  g = f * two;
  h = f * four;
  x ();
  if (f == 0.0 || g == f || g != h)
    regress (zBuf, STRING(FLT_MAX));
  else
    ++test;
}

void
test6_8 ()
{
  double f,g,h;
  double one = 1.0;
  double two = 2.0;
  double four = 4.0;
  char zBuf[ bufSize ];

  sprintf (zBuf, "%.*e", DBL_DIG + 2, DBL_EPSILON);
  sscanf (zBuf, "%le", &f);

  g = f + one;
  h = f / two + one;
  x ();
  if (g - one != f || h - one != 0.0)
    regress (zBuf, STRING(DBL_EPSILON));
  else
    ++test;

  sprintf (zBuf, "%.*e", DBL_DIG + 2, DBL_MIN);
  sscanf (zBuf, "%le", &f);
  g = f * (1 + DBL_EPSILON);
  h = f / two * (1 + DBL_EPSILON);
  x ();
  if (f == 0.0 || f == g || f / two != h)
    regress (zBuf, STRING(DBL_MIN));
  else
    ++test;

  sprintf (zBuf, "%.*e", DBL_DIG + 2, DBL_MAX);
  sscanf (zBuf, "%le", &f);
  g = f * two;
  h = f * four;
  x ();
  if (f == 0.0 || g == f || g != h)
    regress (zBuf, STRING(DBL_MAX));
  else
    ++test;
}

void
test9_11 ()
{
#ifdef HAVE_LONG_DOUBLE
  long double f,g,h;
  long double one = 1.0;
  long double two = 2.0;
  long double four = 4.0;
  char zBuf[ bufSize ];

  sprintf (zBuf, "%.*LeL", LDBL_DIG + 2, LDBL_EPSILON);
  sscanf (zBuf, "%Le", &f);

  g = f + one;
  h = f / two + one;
  x ();
  if (g - one != f || h - one != 0.0)
    regress (zBuf, STRING(LDBL_EPSILON));
  else
    ++test;

  sprintf (zBuf, "%.*LeL", LDBL_DIG + 2, LDBL_MIN);
  sscanf (zBuf, "%Le", &f);
  g = f * (1 + LDBL_EPSILON);
  h = f / two * (1 + LDBL_EPSILON);
  x ();
  if (f == 0.0 || f == g || f / two != h)
    regress (zBuf, STRING(LDBL_MIN));
  else
    ++test;

  sprintf (zBuf, "%.*LeL", LDBL_DIG + 2, LDBL_MAX);
  sscanf (zBuf, "%Le", &f);
  g = f * two;
  h = f * four;
  x ();
  if (f == 0.0 || g == f || g != h)
    regress (zBuf, STRING(LDBL_MAX));
  else
    ++test;
#else
  test += 3;
#endif
}

void
test12_14 ()
{
  static const char *prf_argv[] = {
    "1",   "2",   "3",   "4",   "5",   "6",   "7",   "8",   "9",   "10",
    "11",  "12",  "13",  "14",  "15",  "16",  "17",  "18",  "19",  "20",
    "21",  "22",  "23",  "24",  "25",  "26",  "27",  "28",  "29",  "30",
    "31",  "32",  "33",  "34",  "35",  "36",  "37",  "38",  "39",  "40",
    "41",  "42",  "43",  "44",  "45",  "46",  "47",  "48",  "49",  "50",
    "51",  "52",  "53",  "54",  "55",  "56",  "57",  "58",  "59",  "60",
    "61",  "62",  "63",  "64",  "65",  "66",  "67",  "68",  "69",  "70",
    "71",  "72",  "73",  "74",  "75",  "76",  "77",  "78",  "79",  "80",
    "81",  "82",  "83",  "84",  "85",  "86",  "87",  "88",  "89",  "90",
    "91",  "92",  "93",  "94",  "95",  "96",  "97",  "98",  "99",  "100" };

  static const char prf_fmt12[] = "\
     100 -> %100$s   99 -> %99$s    98 -> %98$s    97 -> %97$s\n\
      96 -> %96$s    95 -> %95$s    94 -> %94$s    93 -> %93$s\n\
      92 -> %92$s    91 -> %91$s    90 -> %90$s    89 -> %89$s\n\
      88 -> %88$s    87 -> %87$s    86 -> %86$s    85 -> %85$s\n\
      84 -> %84$s    83 -> %83$s    82 -> %82$s    81 -> %81$s\n\
      80 -> %80$s    79 -> %79$s    78 -> %78$s    77 -> %77$s\n\
      76 -> %76$s    75 -> %75$s    74 -> %74$s    73 -> %73$s\n\
      72 -> %72$s    71 -> %71$s    70 -> %70$s    69 -> %69$s\n\
      68 -> %68$s    67 -> %67$s    66 -> %66$s    65 -> %65$s\n\
      64 -> %64$s    63 -> %63$s    62 -> %62$s    61 -> %61$s\n\
      60 -> %60$s    59 -> %59$s    58 -> %58$s    57 -> %57$s\n\
      56 -> %56$s    55 -> %55$s    54 -> %54$s    53 -> %53$s\n\
      52 -> %52$s    51 -> %51$s    50 -> %50$s    49 -> %49$s\n\
      48 -> %48$s    47 -> %47$s    46 -> %46$s    45 -> %45$s\n\
      44 -> %44$s    43 -> %43$s    42 -> %42$s    41 -> %41$s\n\
      40 -> %40$s    39 -> %39$s    38 -> %38$s    37 -> %37$s\n\
      36 -> %36$s    35 -> %35$s    34 -> %34$s    33 -> %33$s\n\
      32 -> %32$s    31 -> %31$s    30 -> %30$s    29 -> %29$s\n\
      28 -> %28$s    27 -> %27$s    26 -> %26$s    25 -> %25$s\n\
      24 -> %24$s    23 -> %23$s    22 -> %22$s    21 -> %21$s\n\
      20 -> %20$s    19 -> %19$s    18 -> %18$s    17 -> %17$s\n\
      16 -> %16$s    15 -> %15$s    14 -> %14$s    13 -> %13$s\n\
      12 -> %12$s    11 -> %11$s    10 -> %10$s     9 -> %9$s\n\
       8 -> %8$s      7 -> %7$s      6 -> %6$s      5 -> %5$s\n\
       4 -> %4$s      3 -> %3$s      2 -> %2$s      1 -> %1$s\n\n";

  static const char prf_fmt3[]  = "\
     100 -> %100$d   99 -> %99$d    98 -> %98$d    97 -> %97$d\n\
      96 -> %96$d    95 -> %95$d    94 -> %94$d    93 -> %93$d\n\
      92 -> %92$d    91 -> %91$d    90 -> %90$d    89 -> %89$d\n\
      88 -> %88$d    87 -> %87$d    86 -> %86$d    85 -> %85$d\n\
      84 -> %84$d    83 -> %83$d    82 -> %82$d    81 -> %81$d\n\
      80 -> %80$d    79 -> %79$d    78 -> %78$d    77 -> %77$d\n\
      76 -> %76$d    75 -> %75$d    74 -> %74$d    73 -> %73$d\n\
      72 -> %72$d    71 -> %71$d    70 -> %70$d    69 -> %69$d\n\
      68 -> %68$d    67 -> %67$d    66 -> %66$d    65 -> %65$d\n\
      64 -> %64$d    63 -> %63$d    62 -> %62$d    61 -> %61$d\n\
      60 -> %60$d    59 -> %59$d    58 -> %58$d    57 -> %57$d\n\
      56 -> %56$d    55 -> %55$d    54 -> %54$d    53 -> %53$d\n\
      52 -> %52$d    51 -> %51$d    50 -> %50$d    49 -> %49$d\n\
      48 -> %48$d    47 -> %47$d    46 -> %46$d    45 -> %45$d\n\
      44 -> %44$d    43 -> %43$d    42 -> %42$d    41 -> %41$d\n\
      40 -> %40$d    39 -> %39$d    38 -> %38$d    37 -> %37$d\n\
      36 -> %36$d    35 -> %35$d    34 -> %34$d    33 -> %33$d\n\
      32 -> %32$d    31 -> %31$d    30 -> %30$d    29 -> %29$d\n\
      28 -> %28$d    27 -> %27$d    26 -> %26$d    25 -> %25$d\n\
      24 -> %24$d    23 -> %23$d    22 -> %22$d    21 -> %21$d\n\
      20 -> %20$d    19 -> %19$d    18 -> %18$d    17 -> %17$d\n\
      16 -> %16$d    15 -> %15$d    14 -> %14$d    13 -> %13$d\n\
      12 -> %12$d    11 -> %11$d    10 -> %10$d     9 -> %9$d\n\
       8 -> %8$d      7 -> %7$d      6 -> %6$d      5 -> %5$d\n\
       4 -> %4$d      3 -> %3$d      2 -> %2$d      1 -> %1$d\n\n";

  static const char result13[]  = "\
     100 -> 100   99 -> 99    98 -> 98    97 -> 97\n\
      96 -> 96    95 -> 95    94 -> 94    93 -> 93\n\
      92 -> 92    91 -> 91    90 -> 90    89 -> 89\n\
      88 -> 88    87 -> 87    86 -> 86    85 -> 85\n\
      84 -> 84    83 -> 83    82 -> 82    81 -> 81\n\
      80 -> 80    79 -> 79    78 -> 78    77 -> 77\n\
      76 -> 76    75 -> 75    74 -> 74    73 -> 73\n\
      72 -> 72    71 -> 71    70 -> 70    69 -> 69\n\
      68 -> 68    67 -> 67    66 -> 66    65 -> 65\n\
      64 -> 64    63 -> 63    62 -> 62    61 -> 61\n\
      60 -> 60    59 -> 59    58 -> 58    57 -> 57\n\
      56 -> 56    55 -> 55    54 -> 54    53 -> 53\n\
      52 -> 52    51 -> 51    50 -> 50    49 -> 49\n\
      48 -> 48    47 -> 47    46 -> 46    45 -> 45\n\
      44 -> 44    43 -> 43    42 -> 42    41 -> 41\n\
      40 -> 40    39 -> 39    38 -> 38    37 -> 37\n\
      36 -> 36    35 -> 35    34 -> 34    33 -> 33\n\
      32 -> 32    31 -> 31    30 -> 30    29 -> 29\n\
      28 -> 28    27 -> 27    26 -> 26    25 -> 25\n\
      24 -> 24    23 -> 23    22 -> 22    21 -> 21\n\
      20 -> 20    19 -> 19    18 -> 18    17 -> 17\n\
      16 -> 16    15 -> 15    14 -> 14    13 -> 13\n\
      12 -> 12    11 -> 11    10 -> 10     9 -> 9\n\
       8 -> 8      7 -> 7      6 -> 6      5 -> 5\n\
       4 -> 4      3 -> 3      2 -> 2      1 -> 1\n\n";

  static const char result2[]  = "\
     100 -> 0x64   99 -> 0x63    98 -> 0x62    97 -> 0x61\n\
      96 -> 0x60    95 -> 0x5F    94 -> 0x5E    93 -> 0x5D\n\
      92 -> 0x5C    91 -> 0x5B    90 -> 0x5A    89 -> 0x59\n\
      88 -> 0x58    87 -> 0x57    86 -> 0x56    85 -> 0x55\n\
      84 -> 0x54    83 -> 0x53    82 -> 0x52    81 -> 0x51\n\
      80 -> 0x50    79 -> 0x4F    78 -> 0x4E    77 -> 0x4D\n\
      76 -> 0x4C    75 -> 0x4B    74 -> 0x4A    73 -> 0x49\n\
      72 -> 0x48    71 -> 0x47    70 -> 0x46    69 -> 0x45\n\
      68 -> 0x44    67 -> 0x43    66 -> 0x42    65 -> 0x41\n\
      64 -> 0x40    63 -> 0x3F    62 -> 0x3E    61 -> 0x3D\n\
      60 -> 0x3C    59 -> 0x3B    58 -> 0x3A    57 -> 0x39\n\
      56 -> 0x38    55 -> 0x37    54 -> 0x36    53 -> 0x35\n\
      52 -> 0x34    51 -> 0x33    50 -> 0x32    49 -> 0x31\n\
      48 -> 0x30    47 -> 0x2F    46 -> 0x2E    45 -> 0x2D\n\
      44 -> 0x2C    43 -> 0x2B    42 -> 0x2A    41 -> 0x29\n\
      40 -> 0x28    39 -> 0x27    38 -> 0x26    37 -> 0x25\n\
      36 -> 0x24    35 -> 0x23    34 -> 0x22    33 -> 0x21\n\
      32 -> 0x20    31 -> 0x1F    30 -> 0x1E    29 -> 0x1D\n\
      28 -> 0x1C    27 -> 0x1B    26 -> 0x1A    25 -> 0x19\n\
      24 -> 0x18    23 -> 0x17    22 -> 0x16    21 -> 0x15\n\
      20 -> 0x14    19 -> 0x13    18 -> 0x12    17 -> 0x11\n\
      16 -> 0x10    15 -> 0x0F    14 -> 0x0E    13 -> 0x0D\n\
      12 -> 0x0C    11 -> 0x0B    10 -> 0x0A     9 -> 0x09\n\
       8 -> 0x08      7 -> 0x07      6 -> 0x06      5 -> 0x05\n\
       4 -> 0x04      3 -> 0x03      2 -> 0x02      1 -> 0x01\n\n";

  char *p_result;
  int stat = asprintfv(&p_result, prf_fmt12, (const void**)prf_argv );
  if (stat < 0)
    {
      wrong++;
      fprintf (stderr, "asprintfv returned %d\n", stat);
    }
  else
    regress (p_result, result13);

  free (p_result);

  stat = asprintf(&p_result, prf_fmt12,
      "0x01", "0x02", "0x03", "0x04", "0x05", "0x06", "0x07", "0x08",
      "0x09", "0x0A", "0x0B", "0x0C", "0x0D", "0x0E", "0x0F", "0x10",
      "0x11", "0x12", "0x13", "0x14", "0x15", "0x16", "0x17", "0x18",
      "0x19", "0x1A", "0x1B", "0x1C", "0x1D", "0x1E", "0x1F", "0x20",
      "0x21", "0x22", "0x23", "0x24", "0x25", "0x26", "0x27", "0x28",
      "0x29", "0x2A", "0x2B", "0x2C", "0x2D", "0x2E", "0x2F", "0x30",
      "0x31", "0x32", "0x33", "0x34", "0x35", "0x36", "0x37", "0x38",
      "0x39", "0x3A", "0x3B", "0x3C", "0x3D", "0x3E", "0x3F", "0x40",
      "0x41", "0x42", "0x43", "0x44", "0x45", "0x46", "0x47", "0x48",
      "0x49", "0x4A", "0x4B", "0x4C", "0x4D", "0x4E", "0x4F", "0x50",
      "0x51", "0x52", "0x53", "0x54", "0x55", "0x56", "0x57", "0x58",
      "0x59", "0x5A", "0x5B", "0x5C", "0x5D", "0x5E", "0x5F", "0x60",
      "0x61", "0x62", "0x63", "0x64" );

  if (stat < 0)
    {
      wrong++;
      fprintf (stderr, "asprintfv returned %d\n", stat);
    }
  else
    regress (p_result, result2);

  free (p_result);

  stat = asprintf(&p_result, prf_fmt3,
      0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
      0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
      0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
      0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
      0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
      0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
      0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
      0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,
      0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
      0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
      0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
      0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60,
      0x61, 0x62, 0x63, 0x64 );

  if (stat < 0)
    {
      wrong++;
      fprintf (stderr, "asprintfv returned %d\n", stat);
    }
  else
    regress (p_result, result13);

  free (p_result);

}

int
main()
{
  test1 ();
  test2 ();
  test3_5 ();
  test6_8 ();
  test9_11 ();
  test12_14 ();

  exit (wrong ? EXIT_FAILURE : EXIT_SUCCESS);
}

